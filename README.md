# 香农-范诺算法（Shannon-Fano coding）原理
* 和Huffman-Tree一样，Shannon-Fano coding也是用一棵二叉树对字符进行编码。但在实际操作中呢，Shannon-Fano却没有大用处，这是由于它与Huffman coding相比，编码效率较低的结果（或者说香农-范诺算法的编码平均码字较大）。但是它的基本思路我们还是可以参考下的。
* 根据Wikipedia上面的解释，我们来看下香农范诺算法的原理：
### Shannon-Fano的树是根据旨在定义一个有效的代码表的规范而建立的。实际的算法很简单：
1. 对于一个给定的符号列表，制定了概率相应的列表或频率计数，使每个符号的相对发生频率是已知。
2. 排序根据频率的符号列表，最常出现的符号在左边，最少出现的符号在右边。
3. 清单分为两部分，使左边部分的总频率和尽可能接近右边部分的总频率和。
4. 该列表的左半边分配二进制数字0，右半边是分配的数字1。这意味着，在第一半符号代都是将所有从0开始，第二半的代码都从1开始。
5. 对左、右半部分递归应用步骤3和4，细分群体，并添加位的代码，直到每个符号已成为一个相应的代码树的叶。

### 这个例子展示了一组字母的香浓编码结构（如图a所示）这五个可被编码的字母有如下出现次数:
* Symbol：A  B  C  D  E  
* Count：15  7  6  6  5  
* Probabilities：0.38461538 0.17948718  0.15384615  0.15384615  0.12820513  
* 从左到右，所有的符号以它们出现的次数划分。在字母B与C之间划定分割线，得到了左右两组，总次数分别为22,17。 这样就把两组的差别降到最小。通过这样的分割, A与B同时拥有了一个以0为开头的码字, C，D，E的码子则为1,如图b所示。 随后, 在树的左半边，于A，B间建立新的分割线，这样A就成为了码字为00的叶子节点，B的码子01。经过四次分割, 得到了一个树形编码。 如下表所示，在最终得到的树中, 拥有最大频率的符号被两位编码, 其他两个频率较低的符号被三位编码。
